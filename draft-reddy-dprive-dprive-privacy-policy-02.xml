<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-reddy-dprive-dprive-privacy-policy-02"
     ipr="trust200902">
  <front>
    <title abbrev="DNS Server Filtering Policy">DNS Server Privacy Statement
    and Filtering Policy with Assertion Token</title>

    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization abbrev="McAfee">McAfee, Inc.</organization>

      <address>
        <postal>
          <street>Embassy Golf Link Business Park</street>

          <city>Bangalore</city>

          <region>Karnataka</region>

          <code>560071</code>

          <country>India</country>
        </postal>

        <email>kondtir@gmail.com</email>
      </address>
    </author>

    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Citrix">Citrix Systems, Inc.</organization>

      <address>
        <postal>
          <street></street>

          <country>USA</country>
        </postal>

        <email>dwing-ietf@fuggles.com</email>
      </address>
    </author>

    <author fullname="Michael C. Richardson" initials="M."
            surname="Richardson">
      <organization>Sandelman Software Works</organization>

      <address>
        <postal>
          <street></street>

          <country>USA</country>
        </postal>

        <email>mcr+ietf@sandelman.ca</email>
      </address>
    </author>

    <date />

    <workgroup>DPRIVE WG</workgroup>

    <abstract>
      <t>Users want to control how their DNS queries are handled by DNS
      servers so they can configure their system to use DNS servers that
      comply with their privacy and DNS filtering expectations.</t>

      <t>This document defines a mechanism for a DNS server to communicate its
      privacy statement URL and filtering policy to a DNS client. This
      communication is cryptographically signed to attest to its authenticity.
      By evaluating the DNS privacy statement, filtering policy and the
      signatory, the user can choose a DNS server that best supports their
      desired privacy and filtering policy. This token is particularly useful
      for DNS-over-TLS and DNS-over-HTTPS servers that are either public
      resolvers or are discovered on the local network.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t><xref target="RFC7626"></xref> discusses DNS privacy considerations
      in both "on the wire" (Section 2.4 of <xref target="RFC7626"></xref>)
      and "in the server" (Section 2.5 of <xref target="RFC7626"></xref>
      contexts. In recent years there has also been an increase in the
      availability of "public resolvers" <xref target="RFC8499"></xref> which
      DNS clients may be pre-configured to use instead of the default network
      resolver because they offer a specific feature (e.g., good reachability,
      encrypted transport, strong privacy policy, (lack of) filtering, etc.).
      While a human can review the privacy statement of a DNS server operator,
      but the challenge is the user has to search to find the URL that points
      to the human readable privacy policy information of the DNS server.</t>

      <t>In addition, the user does not know if a locally-discovered server
      performs DNS-based filtering. For DNS servers operated on the local
      network, the DNS client can be securely bootstrapped to discover and
      authenticate DNS-over-TLS and DNS-over-HTTPS servers provided by a local
      network using the technique proposed in <xref
      target="I-D.reddy-dprive-bootstrap-dns-server"></xref>. This document
      defines a retrievable DNS server policy permitting the user to consent
      to using a certain DNS server that meets their needs.</t>

      <t>The cryptographically signed policy allows a DNS client to connect to
      multiple DNS servers and prompt the user to review the DNS privacy
      statements to select the DNS server that adheres to the privacy
      preserving data policy and DNS filtering expectations of the user. For
      example, a browser with pre-configured DNS-over-HTTPS server can
      discover the DNS-over-HTTPS server provided the local network, connects
      to both the DNS servers, gets the policy information from each of the
      DNS servers, validates the signatures and prompts the user to review the
      privacy policy statements of both the local and public DNS server. If
      both servers meet the privacy preserving data policy and DNS filtering
      requirements of the user, the user can select to use the local DNS
      server. A quality implementation can avoid presenting this information
      to the user if the DNS server's policies have not changed.</t>
    </section>

    <section anchor="scope" title="Use Cases Overview ">
      <t>The mechanism for a DNS server to communicate its cryptographically
      signed policies to a DNS client solves the following problems in various
      deployments:<list style="symbols">
          <t>Typically Enterprise networks do not assume that all devices in
          their network are managed by the IT team or Mobile Device Management
          (MDM) devices, especially in the quite common BYOD ("Bring Your Own
          Device") scenario. The mechanism specified in this document can be
          used by users of the BYOD devices to determine if the DNS server on
          the local network complies with the user's privacy policy and DNS
          filtering expectations.</t>

          <t>The user must select specific well known networks (e.g.,
          organization for which a user works or a user works temporarily
          within another corporation) to learn the privacy policy statement
          and filtering policy of the local DNS server, and user can choose to
          use the discovered DNS-over-TLS or DNS-over-HTTPS server. If that
          discovered DNS-over-TLS or DNS-over-HTTPS server does not meet the
          privacy preserving data policy and filtering requirements of the
          user, user can be warned and the user can instruct the client can
          take appropriate action. For example, the action can be to use the
          local DNS server only to access internal-only DNS names and use
          another DNS server for public domains.</t>

          <t>The policy information signals the presence of DNS-based content
          filtering in the attached network. If the network is well known and
          the local DNS server meets the privacy requirements of the user, the
          client can continue to use encrypted connection with the local
          DNS-over-TLS or DNS-over-HTTPS server. If the error code returned by
          the DNS server indicates access to the domain is blocked because of
          internal security policy <xref
          target="I-D.ietf-dnsop-extended-error"></xref>, the client can
          securely identify access to the domain is censored by the
          network.</t>

          <t>The signed policy contains a URL that points to the human
          readable privacy policy information of the DNS server for the user
          to review and can make an informed decision whether the DNS server
          is trustworthy to honor the privacy of the user. The client
          automatically learns updates to the privacy policy of the DNS
          server, and whenever the privacy policy of the DNS server changes,
          the client can notify the user to re-evaluate the updated privacy
          statement. The DNS Push Notifications mechanism defined in <xref
          target="I-D.ietf-dnsop-extended-error"> </xref> can be used by the
          client to be asynchronously notified when the privacy policy change
          occurs.</t>
        </list></t>
    </section>

    <section anchor="notation" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"></xref><xref target="RFC8174"></xref> when, and
      only when, they appear in all capitals, as shown here.</t>

      <t>This document uses the terms defined in <xref
      target="RFC8499"></xref>.</t>
    </section>

    <section anchor="PAT" title="Policy assertion token (PAT) overview">
      <t>JSON Web Token (JWT) <xref target="RFC7519"></xref> and JSON Web
      Signature (JWS) <xref target="RFC7515"></xref> and related
      specifications define a standard token format that can be used as a way
      of encapsulating claimed or asserted information with an associated
      digital signature using X.509 based certificates. JWT provides a set of
      claims in JSON format that can conveniently accommodate asserted policy
      information of the DNS-over-TLS or DNS-over-HTTPS server. Additionally,
      JWS provides a path for updating methods and cryptographic algorithms
      used for the associated digital signatures.</t>

      <t>JWS defines the use of JSON data structures in a specified canonical
      format for signing data corresponding to JOSE header, JWS Payload, and
      JWS Signature. JWT defines a set of claims that are represented by
      specified JSON objects which can be extended with custom keys for
      specific applications. The next sections define the header and claims
      that MUST be minimally used with JWT and JWS for privacy assertion
      token.</t>

      <t>The policy assertion token (PAT) specifically uses this token format
      and defines claims that convey the policy information of DNS-over-TLS or
      DNS-over-HTTPS server. The client can retrieve the PAT object using the
      method discussed in <xref
      target="I-D.ietf-dnsop-resolver-information"></xref>. The signature of
      PAT object can be validated by the DNS client. If the signer and the
      contents of the PAT object comply with the user's requirements, the
      user's client software can use that DNS server.</t>

      <t>The PAT object is signed by the DNS server's domain that is
      authoritative to assert the DNS server policy information. This
      authority is represented by the certificate credentials and the
      signature.</t>

      <t>For example, the PAT object could be created by the domain hosting
      the DNS-over-TLS or DNS-over-HTTPS server and optionally by a third
      party who performed privacy and security audit of the DNS-over-TLS or
      DNS-over-HTTPS server. The DNS client needs to have the capability to
      verify the digital signature and to parse the PAT object.</t>
    </section>

    <section anchor="pat_header" title="PAT Header">
      <t>The JWS token header is a JOSE header, <xref target="RFC7515"></xref>
      Section 4, that defines the type and encryption algorithm used in the
      token.</t>

      <t>PAT header should include, at a minimum, the header parameters
      defined in the next three subsections.</t>

      <section anchor="typ-type-header-parameter"
               title="'typ' (Type) Header Parameter">
        <t>The 'typ' (Type) Header Parameter is defined in JWS <xref
        target="RFC7515"></xref> Section 4.1.9 to declare the media type of
        the complete JWS.</t>

        <t>For PAT Token the 'typ' header MUST be the string 'pat'. This
        represents that the encoded token is a JWT of type pat.</t>
      </section>

      <section anchor="alg-algorithm-header-parameter"
               title="'alg' (Algorithm) Header Parameter">
        <t>The 'alg' (Algorithm) Header Parameter is defined in JWS <xref
        target="RFC7515"></xref> Section 4.1.1, which specifies the JWS
        signature cryptographic algorithm. It also refers to a list of defined
        'alg' values as part of a registry established by JSON Web Algorithms
        (JWA) <xref target="RFC7518"></xref> Section 3.1.</t>

        <t>For the creation and verification of PAT tokens and their digital
        signatures, implementations MUST support ES256 as defined in JWA <xref
        target="RFC7518"></xref> Section 3.4. Implementations MAY support
        other algorithms registered in the JSON Web Signature and Encryption
        Algorithms registry created by <xref target="RFC7518"></xref>. The
        contents of that registry may be updated in the future depending on
        cryptographic strength requirements guided by current security best
        practice. The mandatory-to-support algorithm for PAT tokens may
        likewise be updated in future updates to this document.</t>

        <t>Implementations of PAT digital signatures using ES256 as defined
        above SHOULD use deterministic ECDSA if/when supported for the reasons
        stated in <xref target="RFC6979"></xref>.</t>
      </section>

      <section anchor="x5u-x509-url-header-parameter"
               title="'x5u' (X.509 URL) Header Parameter">
        <t>As defined in JWS <xref target="RFC7515"></xref> Section 4.1.5.,
        the 'x5u' header parameter defines a URI <xref
        target="RFC3986"></xref> referring to the resource for the X.509
        public key certificate or certificate chain <xref
        target="RFC5280"></xref> corresponding to the key used to digitally
        sign the JWS. Generally, as defined in JWS <xref
        target="RFC7515"></xref> section 4.1.5, this would correspond to an
        HTTPS or DNSSEC resource using integrity protection.</t>
      </section>

      <section anchor="example-pat-header" title="Example PAT header">
        <t>An example of the header, would be the following, including the
        specified pat type, ES256 algorithm, and a URI referencing the network
        location of the certificate needed to validate the PAT signature.</t>

        <figure>
          <artwork><![CDATA[
{
  "typ":"pat",
  "alg":"ES256",
  "x5u":"https://cert.example.com/pat.cer"
}
]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="pat_payload" title="PAT Payload">
      <t>The token claims consists of the privacy policy information of the
      DNS server which needs to be verified at the DNS client. These claims
      follow the definition of a JWT claim <xref target="RFC7519"></xref>
      Section 4 and are encoded as defined by the JWS Payload <xref
      target="RFC7515"></xref> Section 3.</t>

      <t>PAT defines the use of a standard JWT defined claim as well as custom
      claims corresponding to the DNS-over-TLS or DNS-over-HTTPS servers.</t>

      <t>Any claim names MUST use the US-ASCII character set. Any claim values
      can contain characters that are outside the US-ASCII range, however MUST
      follow the default JSON serialization defined in <xref
      target="RFC7519"></xref> Section 7.</t>

      <section anchor="jwt-defined-claims" title="JWT defined claims">
        <section anchor="iat-issued-at-claim" title="'iat' - Issued At claim">
          <t>The JSON claim MUST include the 'iat' <xref
          target="RFC7519"></xref> Section 4.1.6 defined claim Issued At. As
          defined the 'iat' should be set to the date and time of issuance of
          the JWT. The time value should be of the format defined in <xref
          target="RFC7519"></xref> Section 2 NumericDate.</t>
        </section>

        <section anchor="exp-header-parameter"
                 title="'exp' - Expiration Time claim">
          <t>The JSON claim MUST include the 'exp' <xref
          target="RFC7519"></xref> Section 4.1.4 defined claim Expiration
          Time. As defined the 'exp' should be set to specify the expiration
          time on or after which the JWT is not accepted for processing. The
          PAT object should generally expire after a reasonable duration. A
          short expiration time for the PAT object periodically reaffirms the
          privacy policy information of the DNS server to the client and
          ensures the client does not use outdated privacy policy information.
          If the client knows the PAT object has expired, it makes another
          request to get the new PAT object from the DNS server.</t>
        </section>
      </section>

      <section anchor="pat_claims" title="PAT specific claims">
        <section anchor="server-identity" title="DNS server Identity Claims">
          <t>The DNS server identity is represented by a claim that is
          required for PAT, the 'server' claim. The 'server' MUST contain
          claim values that are identity claim JSON objects where the child
          claim name represents an identity type and the claim value is the
          identity string, both defined in subsequent subsections. Currently,
          these identities can be represented as either authentication domain
          name (ADN) (defined in <xref target="RFC8310"></xref>) or Uniform
          Resource Indicators (URI).</t>

          <section anchor="adn"
                   title="'adn' - authentication domain name identity">
            <t>If the DNS server identity is a ADN, the claim name
            representing the identity MUST be 'adn'. The claim value for the
            'adn' claim is the ADN.</t>
          </section>

          <section anchor="uri-identity" title="'uri' - URI identity">
            <t>If the DNS server identity is of the form URI, as defined in
            <xref target="RFC3986"></xref>, the claim name representing the
            identity MUST be 'uri' and the claim value is the URI form of the
            DNS server identity. As a reminder, if DNS-over-HTTPS protocol is
            supported by the DNS server, the DNS client uses the https URI
            scheme (Section 3 of <xref target="RFC8484"></xref>).</t>
          </section>
        </section>

        <section anchor="policyinfo"
                 title="'policyinfo' (Policy Information) Claim">
          <t>The 'policyinfo' claim MUST be formatted as a JSON object. The
          'policyinfo' claim contains the privacy policy information of the
          DNS server, it includes the following attributes:</t>

          <t><list style="hanging">
              <t hangText="filtering:">If the DNS server changes some of the
              answers that it returns based on policy criteria, such as to
              prevent access to malware sites or objectionable content. This
              optional attribute has the following structure: <list
                  style="hanging">
                  <t hangText="malwareblocking:">The DNS server offers malware
                  blocking service. If access to domains is blocked on threat
                  data, the parameter value is set to 'true'.</t>

                  <t hangText="policyblocking:">If access to domains is
                  blocked on a blacklist or objectionable content, the
                  parameter value is set to 'true'.</t>
                </list></t>

              <t hangText="qnameminimization:">If the DNS server implements
              QNAME minimisation <xref target="RFC7816"></xref> to improve DNS
              privacy. If the parameter value is set to 'true', QNAME
              minimisation is supported by the DNS server. This is a mandatory
              attribute.</t>

              <t hangText="privacyurl:">A URL that points to the privacy
              policy information of the DNS server. This is a mandatory
              attribute.</t>

              <t hangText="auditurl:">A URL that points to the security
              assessment report of the DNS server by a third party auditor.
              This is an optional attribute.</t>
            </list></t>
        </section>

        <section anchor="pat_payload_example" title="Example">
          <t>The below Figure shows an example of policy information.</t>

          <figure>
            <artwork><![CDATA[{
  "server":{
      "adn":["example.com"]
  },
  "iat":1443208345,
  "exp":1443640345,
  "policyinfo": {
     "filtering": {
         "malwareblocking": true,
         "policyblocking": false
     },
     "qnameminimization":false,
     "privacyurl": "https://example.com/commitment-to-privacy/"
  } 
}
]]></artwork>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="pat_signature" title="PAT Signature">
      <t>The signature of the PAT is created as specified by JWS <xref
      target="RFC7515"></xref> Section 5.1 Steps 1 through 6. PAT MUST use the
      JWS Protected Header. For the JWS Payload and the JWS Protected Header,
      the lexicographic ordering and white space rules described in <xref
      target="pat_header"></xref> and <xref target="pat_payload"></xref>, and
      JSON serialization rules in <xref target="json_serialization"></xref> of
      this document MUST be followed.</t>

      <t>The PAT is cryptographically signed by the domain hosting the DNS
      server and optionally by a third party who performed privacy and
      security audit of the DNS server. The privacy policy information will be
      attested using "Organization Validation" (OV) or "Extended Validation"
      (EV) certificates to avoid bad actors taking advantage of this mechanism
      to advertise DNS-over-TLS and DNS-over-HTTPS servers for illegitimate
      and fraudulent purposes meant to trick DNS clients into believing that
      they are using a legitimate DNS-over-TLS or DNS-over-HTTPS server hosted
      to provide privacy for DNS transactions. Alternatively, the DNS client
      will have to be configured to trust the leaf of the signer of the PAT
      object. That is, trust of the signer MUST NOT be determined by
      validating the signer via the OS or browser trust chain because that
      would allow any arbitrary entity to operate a DNS server and assert any
      sort of privacy policy.</t>

      <t><xref
      target="example-es256-based-pat-jws-serialization-and-signature"></xref>
      of this document has a detailed example of how to follow the steps to
      create the JWS Signature.</t>

      <t>JWS <xref target="RFC7515"></xref> Section 5.1 Step 7 JWS JSON
      serialization is supported for PAT to enable multiple signatures to be
      applied to the PAT object. For example, the PAT object can be
      cryptographically signed by the domain hosting the DNS server and by a
      third party who performed privacy and security audit of the DNS
      server.</t>

      <t><xref
      target="example-es256-based-pat-jws-serialization-and-signatures"></xref>
      of this document has a example of complete JWS JSON serialization
      representation with multiple signatures.</t>

      <t>JWS <xref target="RFC7515"></xref> Section 5.1 Step 8 describes the
      method to create the final JWS Compact Serialization form of the PAT
      Token.</t>
    </section>

    <section anchor="extending_pat" title="Extending PAT">
      <t>PAT includes the minimum set of claims needed to securely assert the
      privacy policy information of the DNS server. JWT supports a straight
      forward way to add additional asserted or signed information by simply
      adding new claims. PAT can be extended beyond the defined base set of
      claims to represent other DNS server information requiring assertion or
      validation. Specifying new claims follows the baseline JWT procedures
      (<xref target="RFC7519"></xref> Section 10.1). Understanding new claims
      on the DNS client is optional. The creator of a PAT object cannot assume
      that the DNS client will understand the new claims.</t>
    </section>

    <section anchor="json_serialization"
             title="Deterministic JSON Serialization">
      <t>JSON objects can include spaces and line breaks, and key value pairs
      can occur in any order. It is therefore a non-deterministic string
      format. In order to make the digital signature verification work
      deterministically, the JSON representation of the JWS Protected Header
      object and JWS Payload object MUST be computed as follows.</t>

      <t>The JSON object MUST follow the following rules. These rules are
      based on the thumbprint of a JSON Web Key (JWK) as defined in Section 3
      Step 1 of <xref target="RFC7638"></xref>.</t>

      <t><list style="numbers">
          <t>The JSON object MUST contain no whitespace or line breaks before
          or after any syntactic elements.</t>

          <t>JSON objects MUST have the keys ordered lexicographically by the
          Unicode <xref target="UNICODE"></xref> code points of the member
          names.</t>

          <t>JSON value literals MUST be lowercase.</t>

          <t>JSON numbers are to be encoded as integers unless the field is
          defined to be encoded otherwise.</t>

          <t>Encoding rules MUST be applied recursively to member values and
          array values.</t>
        </list></t>

      <section anchor="example-pat-deterministic-json-form"
               title="Example PAT deterministic JSON form">
        <t>This section demonstrates the deterministic JSON serialization for
        the example PAT Payload shown in <xref
        target="pat_payload_example"></xref>.</t>

        <t>The initial JSON object is shown here:</t>

        <figure>
          <artwork><![CDATA[{
  "server":{
      "adn":["example.com"]
  },
  "iat":1443208345,
  "exp":1443640345,
  "policyinfo": {
     "qnameminimization":false,
     "privacyurl": "https://example.com/commitment-to-privacy/"
  } 
}
]]></artwork>
        </figure>

        <t>The parent members of the JSON object are as follows, in
        lexicographic order: "exp", "iat", "policyinfo", "server".</t>

        <t>The final constructed deterministic JSON serialization
        representation, with whitespace and line breaks removed, (with line
        breaks used for display purposes only) is:</t>

        <figure>
          <artwork><![CDATA[{"exp":1443640345,"iat":1443208345,
"policyinfo":{"privacyurl":"https://example.com/commitment-to-privacy/",
"qnameminimization":false},"server":{"adn":["example.com"]}}
]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="privacy" title="Privacy Considerations">
      <t>Users are expected to indicate to their system in some way that they
      trust certain PAT signers (e.g., if working for Example, Inc., the
      user's system is configured to trust example.com signing the PAT). By
      doing so, the DNS client can automatically discover local DNS-over-TLS
      or DNS-over-HTTPS server in specific networks, validate the PAT
      signature and the user can check if the human readable privacy policy
      information of the DNS server complies with user's privacy needs, prior
      to using that DNS-over-TLS or DNS-over-HTTPS server for DNS queries. The
      client MUST retrieve the human-readable privacy statement from the
      'privacyurl' attribute to assist with that decision (e.g., display the
      privacy statement when it changes, show differences in
      previously-retrieved version, etc.). With the steps above, user consent
      is obtained prior to using a locally-discovered DNS-over-TLS or
      DNS-over-HTTPS server for DNS queries.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The use of PAT object based on the validation of the digital
      signature and the associated certificate requires consideration of the
      authentication and authority or reputation of the signer to attest the
      privacy policy information of the DNS server being asserted. Bad actors
      can host DNS-over-TLS and DNS-over-HTTPS servers, and claim the servers
      offer privacy but exactly do the opposite to invade the privacy of the
      user. Bad actor can get a domain name, host DNS-over-TLS and
      DNS-over-HTTPS servers, and get the DNS server certificate signed by a
      CA. The privacy policy information will have to be attested using OV/EV
      certificates or a PAT object signer trusted by the DNS client to prevent
      the attack.</t>

      <t>If the PAT object is asserted by a third party, it can do a "time of
      check" but the DNS server is susceptible of "time of use" attack. For
      example, changes to privacy policy of the DNS server like sharing
      identifiable transaction data with partners can cause a disagreement
      between the auditor and the DNS server operation. In other words, the
      DNS server might have complied with the privacy policy when it was
      audited (by the 3rd party) but could now be in non-compliance with its
      privacy policy, hence the PAT object needs to be also asserted by the
      domain hosting the DNS server. In addition, the PAT object needs to have
      a short expiration time (e.g., 7 days) to ensure the DNS server's domain
      re-asserts the privacy policy information and limits the damage from
      change in privacy policy and mis-issuance.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <section anchor="media-type-registration"
               title="Media Type Registration">
        <section anchor="media-type-registry-contents-additions-requested"
                 title="Media Type Registry Contents Additions Requested">
          <t>This section registers the 'application/pat' media type <xref
          target="RFC2046"></xref> in the 'Media Types' registry in the manner
          described in <xref target="RFC6838"></xref>, which can be used to
          indicate that the content is a PAT defined JWT.</t>

          <t><list style="symbols">
              <t>Type name: application</t>

              <t>Subtype name: pat</t>

              <t>Required parameters: n/a</t>

              <t>Optional parameters: n/a</t>

              <t>Encoding considerations: 8bit; application/pat values are
              encoded as a series of base64url-encoded values (some of which
              may be the empty string) separated by period (&lsquo;.&rsquo;)
              characters..</t>

              <t>Security considerations: See the Security Considerations
              Section of <xref target="RFC7515"></xref>.</t>

              <t>Interoperability considerations: n/a</t>

              <t>Published specification: [TODO this document]</t>

              <t>Applications that use this media type: DNS</t>

              <t>Fragment identifier considerations: n/a</t>

              <t>Additional information: <vspace blankLines="1" /> Magic
              number(s): n/a File extension(s): n/a Macintosh file type
              code(s): n/a</t>

              <t>Person &amp; email address to contact for further
              information: Tirumaleswar Reddy, kondtir@gmail.com</t>

              <t>Intended usage: COMMON</t>

              <t>Restrictions on usage: none</t>

              <t>Author: Tirumaleswar Reddy, kondtir@gmail.com</t>

              <t>Change Controller: IESG</t>

              <t>Provisional registration? No</t>
            </list></t>
        </section>
      </section>

      <section anchor="json-web-token-claims-registration"
               title="JSON Web Token Claims Registration">
        <section anchor="registry-contents-additions-requested"
                 title="Registry Contents Additions Requested">
          <t><list style="symbols">
              <t>Claim Name: 'server'</t>

              <t>Claim Description: DNS server identity</t>

              <t>Change Controller: IESG</t>

              <t>Specification Document(s): <xref
              target="server-identity"></xref> of [TODO this document]</t>

              <t>Claim Name: 'policyinfo'</t>

              <t>Claim Description: Privacy policy information of DNS
              server.</t>

              <t>Change Controller: IESG</t>

              <t>Specification Document(s): <xref target="policyinfo"></xref>
              of [TODO this document]</t>
            </list></t>
        </section>
      </section>

      <section anchor="resolver-information"
               title="DNS Resolver Information Registration">
        <t>IANA will add the names filtering, qnameminimization, privacyurl,
        auditurl and upstreamserverpat to the DNS Resolver Information
        registry defined in Section 5.2 of <xref
        target="I-D.ietf-dnsop-resolver-information"></xref>.</t>
      </section>
    </section>

    <section anchor="acknowledgments" title="Acknowledgments">
      <t>This specification leverages some of the work that has been done in
      <xref target="RFC8225"></xref>. Thanks to Ted Lemon, Paul Wouters and
      Shashank Jain for the discussion and comments.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include='reference.RFC.8174'?>

      <?rfc include="reference.RFC.8484"?>

      <?rfc include="reference.RFC.8499"?>

      <?rfc include="reference.RFC.5280"?>

      <?rfc include="reference.RFC.7515"?>

      <?rfc include="reference.RFC.7519"?>

      <?rfc include="reference.RFC.7518"?>

      <?rfc include="reference.RFC.6979"?>

      <?rfc include="reference.RFC.3986"?>

      <?rfc include="reference.RFC.7638"?>

      <?rfc include="reference.RFC.6838"?>

      <?rfc include="reference.RFC.2046"?>

      <?rfc include='reference.I-D.ietf-dnsop-resolver-information'?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.8310"?>

      <?rfc include="reference.RFC.7626"?>

      <?rfc include="reference.RFC.7816"?>

      <?rfc include="reference.RFC.8225"?>

      <?rfc include='reference.I-D.reddy-dprive-bootstrap-dns-server'?>

      <?rfc include='reference.I-D.ietf-dnsop-extended-error'?>

      <reference anchor="UNICODE"
                 target="http://www.unicode.org/versions/latest/">
        <front>
          <title>The Unicode Standard</title>

          <author>
            <organization>The Unicode Consortium</organization>
          </author>

          <date day="21" month="June" year="2016" />
        </front>
      </reference>
    </references>

    <section anchor="example-es256-based-pat-jws-serialization-and-signature"
             title="Example ES256 based PAT JWS Serialization and Signature">
      <t>For PAT, there will always be a JWS with the following members:</t>

      <t><list style="symbols">
          <t>'protected', with the value BASE64URL(UTF8(JWS Protected
          Header))</t>

          <t>'payload', with the value BASE64URL (JWS Payload)</t>

          <t>'signature', with the value BASE64URL(JWS Signature)</t>
        </list></t>

      <t>This example will follow the steps in JWS <xref
      target="RFC7515"></xref> Section 5.1, steps 1-6 and 8 and incorporates
      the additional serialization steps required for PAT.</t>

      <t>Step 1 for JWS references the JWS Payload, an example PAT Payload is
      as follows:</t>

      <figure>
        <artwork><![CDATA[{
  "server":{
      "adn":["example.com"]
  },
  "iat":1443208345,
  "exp":1443640345,
  "policyinfo": {
     "filtering": {
         "malwareblocking": true,
         "policyblocking": false
     },
     "qnameminimization":false,
     "privacyurl": "https://example.com/commitment-to-privacy/"
  } 
}
]]></artwork>
      </figure>

      <t>This would be serialized to the form (with line break used for
      display purposes only):</t>

      <figure>
        <artwork><![CDATA[{"exp":1443640345,"iat":1443208345,"policyinfo":{
"filtering":{"malwareblocking": true,"policyblocking": false},
"privacyurl":"https://example.com/commitment-to-privacy/",
"qnameminimization":false},"server":{"adn":["example.com"]}}
]]></artwork>
      </figure>

      <t>Step 2 Computes the BASE64URL(JWS Payload) producing this value (with
      line break used for display purposes only):</t>

      <figure>
        <artwork><![CDATA[
eyJleHAiOjE0NDM2NDAzNDUsImlhdCI6MTQ0MzIwODM0NSwicG9saWN5aW5mbyI6e
yJmaWx0ZXJpbmciOnsibWFsd2FyZWJsb2NraW5nIjp0cnVlLCJwb2xpY3libG9ja2
luZyI6ZmFsc2V9LCJwcml2YWN5dXJsIjoiaHR0cHM6Ly9leGFtcGxlLmNvbS9jb21
taXRtZW50LXRvLXByaXZhY3kvIiwicW5hbWVtaW5pbWl6YXRpb24iOmZhbHNlfSwi
c2VydmVyIjp7ImFkbiI6WyJleGFtcGxlLmNvbSJdfX0


]]></artwork>
      </figure>

      <t>For Step 3, an example PAT Protected Header comprising the JOSE
      Header is as follows:</t>

      <figure>
        <artwork><![CDATA[
{
  "alg":"ES256",
  "typ":"pat",
  "x5u":"https://cert.example.com/pat.cer"
}
]]></artwork>
      </figure>

      <t>This would be serialized to the form (with line break used for
      display purposes only):</t>

      <figure>
        <artwork><![CDATA[
{"alg":"ES256","typ":"pat","x5u":"https://cert.example.com
/pat.cer"}
]]></artwork>
      </figure>

      <t>Step 4 Performs the BASE64URL(UTF8(JWS Protected Header)) operation
      and encoding produces this value (with line break used for display
      purposes only):</t>

      <figure>
        <artwork><![CDATA[
eyJhbGciOiJFUzI1NiIsInR5cCI6InBhdCIsIng1dSI6Imh0dHBzOi8vY2VydC5l
eGFtcGxlLmNvbS9wYXQuY2VyIn0


]]></artwork>
      </figure>

      <t>Step 5 and Step 6 performs the computation of the digital signature
      of the PAT Signing Input ASCII(BASE64URL(UTF8(JWS Protected Header)) ||
      &lsquo;.&rsquo; || BASE64URL(JWS Payload)) using ES256 as the algorithm
      and the BASE64URL(JWS Signature).</t>

      <figure>
        <artwork><![CDATA[
4vQEAF_Vlp1Tr6sJmS4pnIKDRmIjH8EZzY5BMT2qJCHD8PmjBktWVnlmbmyHs05G
KauRBdIFnfp3oDPbE0Jq4w

]]></artwork>
      </figure>

      <t>Step 8 describes how to create the final PAT token, concatenating the
      values in the order Header.Payload.Signature with period
      (&lsquo;.&rsquo;) characters. For the above example values this would
      produce the following (with line breaks between period used for
      readability purposes only):</t>

      <figure>
        <artwork><![CDATA[
eyJhbGciOiJFUzI1NiIsInR5cCI6InBhdCIsIng1dSI6Imh0dHBzOi8vY2VydC5l
eGFtcGxlLmNvbS9wYXQuY2VyIn0
.
eyJleHAiOjE0NDM2NDAzNDUsImlhdCI6MTQ0MzIwODM0NSwicG9saWN5aW5mbyI6e
yJmaWx0ZXJpbmciOnsibWFsd2FyZWJsb2NraW5nIjp0cnVlLCJwb2xpY3libG9ja2
luZyI6ZmFsc2V9LCJwcml2YWN5dXJsIjoiaHR0cHM6Ly9leGFtcGxlLmNvbS9jb21
taXRtZW50LXRvLXByaXZhY3kvIiwicW5hbWVtaW5pbWl6YXRpb24iOmZhbHNlfSwi
c2VydmVyIjp7ImFkbiI6WyJleGFtcGxlLmNvbSJdfX0
.
4vQEAF_Vlp1Tr6sJmS4pnIKDRmIjH8EZzY5BMT2qJCHD8PmjBktWVnlmbmyHs05G
KauRBdIFnfp3oDPbE0Jq4w
]]></artwork>
      </figure>

      <section anchor="x509-private-key-in-pkcs8-format-for-es256-example"
               title="X.509 Private Key in PKCS#8 format for ES256 Example**">
        <figure>
          <artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgevZzL1gdAFr88hb2
OF/2NxApJCzGCEDdfSp6VQO30hyhRANCAAQRWz+jn65BtOMvdyHKcvjBeBSDZH2r
1RTwjmYSi9R/zpBnuQ4EiMnCqfMPWiZqB4QdbAd0E7oH50VpuZ1P087G
-----END PRIVATE KEY-----
]]></artwork>
        </figure>
      </section>

      <section anchor="x509-public-key-for-es256-example"
               title="X.509 Public Key for ES256 Example**">
        <figure>
          <artwork><![CDATA[
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEVs/o5+uQbTjL3chynL4wXgUg2R9
q9UU8I5mEovUf86QZ7kOBIjJwqnzD1omageEHWwHdBO6B+dFabmdT9POxg==
-----END PUBLIC KEY-----
]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="example-es256-based-pat-jws-serialization-and-signatures"
             title="Complete JWS JSON Serialization Representation with multiple Signatures">
      <t>The JWS payload used in this example as follows.</t>

      <t><figure>
          <artwork><![CDATA[{
  "server":{
      "adn":["example.com"]
  },
  "iat":1443208345,
  "exp":1443640345,
  "policyinfo": {
     "filtering": {
         "malwareblocking": true,
         "policyblocking": false
     },
     "qnameminimization":false,
     "privacyurl": "https://example.com/commitment-to-privacy/"
  } 
}
]]></artwork>
        </figure></t>

      <t>This would be serialized to the form (with line break used for
      display purposes only):</t>

      <figure>
        <artwork><![CDATA[{"exp":1443640345,"iat":1443208345,"policyinfo":{
"filtering":{"malwareblocking": true,"policyblocking": false},
"privacyurl":"https://example.com/commitment-to-privacy/",
"qnameminimization":false},"server":{"adn":["example.com"]}}
]]></artwork>
      </figure>

      <t></t>

      <t>The JWS protected Header value used for the first signature is same
      as that used in the example in <xref
      target="example-es256-based-pat-jws-serialization-and-signature"></xref>.
      The X.509 private key used for generating the first signature is same as
      that used in the example in <xref
      target="x509-private-key-in-pkcs8-format-for-es256-example"></xref>.</t>

      <t>The JWS Protected Header value used for the second signature is:</t>

      <t><figure>
          <artwork><![CDATA[{
  "alg":"ES384",
  "typ":"pat",
  "x5u":"https://cert.audit-example.com/pat.cer"
}
]]></artwork>
        </figure></t>

      <t>The complete JWS JSON Serialization for these values is as follows
      (with line breaks within values for display purposes only):</t>

      <figure>
        <artwork><![CDATA[{
  "payload":
       "eyJleHAiOjE0NDM2NDAzNDUsImlhdCI6MTQ0MzIwODM0NSwicG9saWN5aW5mbyI6
        eyJmaWx0ZXJpbmciOnsibWFsd2FyZWJsb2NraW5nIjp0cnVlLCJwb2xpY3libG9j
        a2luZyI6ZmFsc2V9LCJwcml2YWN5dXJsIjoiaHR0cHM6Ly9leGFtcGxlLmNvbS9j
        b21taXRtZW50LXRvLXByaXZhY3kvIiwicW5hbWVtaW5pbWl6YXRpb24iOmZhbHNl
        fSwic2VydmVyIjp7ImFkbiI6WyJleGFtcGxlLmNvbSJdfX0",
  "signatures":[
       {"protected":"eyJhbGciOiJFUzI1NiIsInR5cCI6InBhdCIsIng1dSI6Imh0dHB
        zOi8vY2VydC5leGFtcGxlLmNvbS9wYXQuY2VyIn0",
        "signature": "4vQEAF_Vlp1Tr6sJmS4pnIKDRmIjH8EZzY5BMT2qJCHD8PmjBk
        tWVnlmbmyHs05GKauRBdIFnfp3oDPbE0Jq4w"},
       {"protected":"eyJhbGciOiJFUzM4NCIsInR5cCI6InBhdCIsIng1dSI6Imh0dHB
          zOi8vY2VydC5hdWRpdC1leGFtcGxlLmNvbS9wYXQuY2VyIn0",
        "signature":666ag_mAqDa3Oyxo1DGXUocr0MmRjpXwq8kWp1S21mvs2-kPCIq3
        0xsBJt4apy-sq3VyJgIqzjijoFYURhHvupF0obo-IFUGSZ1YHBCX_MiyBwJQJjtp
        S91ujDatRTtZ"}]
}
]]></artwork>
      </figure>

      <section anchor="x509-private-key-in-pkcs8-format-for-es384-example"
               title="X.509 Private Key in PKCS#8 format for E384 Example**">
        <figure>
          <artwork><![CDATA[
-----BEGIN PRIVATE KEY-----
MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgevZzL1gdAFr88hb2
OF/2NxApJCzGCEDdfSp6VQO30hyhRANCAAQRWz+jn65BtOMvdyHKcvjBeBSDZH2r
1RTwjmYSi9R/zpBnuQ4EiMnCqfMPWiZqB4QdbAd0E7oH50VpuZ1P087G
-----END PRIVATE KEY-----
]]></artwork>
        </figure>
      </section>

      <section anchor="x509-public-key-for-es384-example"
               title="X.509 Public Key for ES384 Example**">
        <figure>
          <artwork><![CDATA[
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEVs/o5+uQbTjL3chynL4wXgUg2R9
q9UU8I5mEovUf86QZ7kOBIjJwqnzD1omageEHWwHdBO6B+dFabmdT9POxg==
-----END PUBLIC KEY-----
]]></artwork>
        </figure>
      </section>
    </section>
  </back>
</rfc>
